<!DOCTYPE html>
<html lang="en" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Profile Viewer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/alpinejs@3.x.x/dist/cdn.min.js"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        wb: {
                            bg: '#0d1117',
                            card: '#161b22',
                            border: '#30363d',
                            hover: '#1f2428',
                            text: '#c9d1d9',
                            muted: '#8b949e',
                            accent: '#f59e0b',
                            accentHover: '#d97706',
                            green: '#3fb950',
                            red: '#f85149',
                            blue: '#58a6ff',
                            purple: '#a371f7',
                        }
                    }
                }
            }
        }
    </script>
    <style>
        [x-cloak] { display: none !important; }
        body { background-color: #0d1117; color: #c9d1d9; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif; }
        .drop-zone { border: 2px dashed #30363d; transition: all 0.2s; }
        .drop-zone.dragover { border-color: #f59e0b; background-color: rgba(245, 158, 11, 0.05); }
        .table-scroll::-webkit-scrollbar { width: 6px; height: 6px; }
        .table-scroll::-webkit-scrollbar-track { background: #161b22; }
        .table-scroll::-webkit-scrollbar-thumb { background: #30363d; border-radius: 3px; }
        .table-scroll::-webkit-scrollbar-thumb:hover { background: #484f58; }
        .mono { font-family: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace; }
        .stat-value { font-variant-numeric: tabular-nums; }
    </style>
</head>
<body class="min-h-screen" x-data="profileViewer()" x-init="init()">
    <div class="max-w-[1600px] mx-auto px-4 py-4">
        <!-- Header -->
        <header class="flex items-center justify-between mb-4 pb-3 border-b border-wb-border">
            <div class="flex items-center gap-3">
                <div class="w-8 h-8 bg-wb-accent rounded flex items-center justify-center">
                    <svg class="w-4 h-4 text-black" fill="currentColor" viewBox="0 0 20 20">
                        <path d="M2 10a8 8 0 018-8v8h8a8 8 0 11-16 0z"/><path d="M12 2.252A8.014 8.014 0 0117.748 8H12V2.252z"/>
                    </svg>
                </div>
                <h1 class="text-lg font-semibold text-white">Profile Viewer</h1>
            </div>
            <div class="flex items-center gap-2" x-show="data">
                <select x-model="selectedIndex" @change="onModelChange()" 
                        class="bg-wb-card border border-wb-border rounded px-2 py-1 text-sm text-wb-text focus:border-wb-accent focus:outline-none">
                    <template x-for="(m, i) in data" :key="i">
                        <option :value="i" x-text="`${m.size || 'Model '+i} · ${formatParams(m.num_params)} · ctx=${m.context_length} · ${m.precision || (m.use_amp ? 'BF16' : 'FP32')}`"></option>
                    </template>
                </select>
            </div>
        </header>

        <!-- Upload Zone -->
        <div x-show="!data" x-cloak
             class="drop-zone rounded-lg p-12 text-center cursor-pointer mb-4"
             :class="{ 'dragover': isDragging }"
             @click="$refs.fileInput.click()"
             @dragover.prevent="isDragging = true"
             @dragleave="isDragging = false"
             @drop.prevent="isDragging = false; handleDrop($event)">
            <svg class="w-10 h-10 text-wb-muted mx-auto mb-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="1.5" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
            </svg>
            <p class="text-wb-text mb-1">Drop JSON profile here or click to browse</p>
            <p class="text-wb-muted text-sm">Supports array or single profile format</p>
            <input type="file" x-ref="fileInput" @change="handleFile($event)" accept=".json" class="hidden">
            <button @click.stop="loadDemo()" class="mt-4 bg-wb-accent hover:bg-wb-accentHover text-black text-sm font-medium px-4 py-1.5 rounded transition">
                Load Demo
            </button>
        </div>

        <!-- Main Content -->
        <div x-show="model" x-cloak>
            <!-- Model Info Bar -->
            <div class="flex flex-wrap items-center gap-x-4 gap-y-1 text-xs mb-4 px-1">
                <template x-for="item in modelMeta" :key="item.label">
                    <span class="text-wb-muted"><span x-text="item.label"></span>: <span class="text-wb-text" x-text="item.value"></span></span>
                </template>
            </div>

            <!-- Stats Row -->
            <div class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-6 gap-3 mb-4">
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Forward <span class="text-wb-green">(per step)</span></div>
                    <div class="text-xl font-semibold text-white stat-value" x-text="formatTime(fwdPerStep)"></div>
                    <div class="text-xs text-wb-muted mt-0.5"><span x-text="model?.forward?.num_events || 0"></span> events</div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Fwd+Bwd <span class="text-wb-accent">(per step)</span></div>
                    <div class="text-xl font-semibold text-white stat-value" x-text="formatTime(fwdBwdPerStep)"></div>
                    <div class="text-xs text-wb-muted mt-0.5"><span x-text="model?.backward?.num_events || 0"></span> events</div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Train Step <span class="text-wb-blue">(per step)</span></div>
                    <div class="text-xl font-semibold text-white stat-value" x-text="formatTime(trainPerStep)"></div>
                    <div class="text-xs text-wb-muted mt-0.5"><span x-text="model?.train?.num_events || 0"></span> events</div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Bwd Only <span class="text-wb-accent">(per step)</span></div>
                    <div class="text-xl font-semibold text-white stat-value" x-text="formatTime(bwdOnlyPerStep)"></div>
                    <div class="text-xs text-wb-muted mt-0.5">fwd+bwd − fwd</div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Optim Only <span class="text-wb-blue">(per step)</span></div>
                    <div class="text-xl font-semibold text-white stat-value" x-text="formatTime(optimOnlyPerStep)"></div>
                    <div class="text-xs text-wb-muted mt-0.5">train − fwd+bwd</div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-3">
                    <div class="text-xs text-wb-muted mb-1">Bwd/Fwd Ratio</div>
                    <div class="text-xl font-semibold text-wb-accent stat-value" x-text="bwdFwdRatio"></div>
                    <div class="text-xs text-wb-muted mt-0.5">bwd only / fwd</div>
                </div>
            </div>

            <!-- Precision Comparison (only shown when both FP32 and BF16 data exists) -->
            <div x-show="hasPrecisionComparison" class="bg-wb-card border border-wb-border rounded-lg p-4 mb-4">
                <div class="text-sm font-medium text-white mb-3">
                    Precision Comparison: <span class="text-wb-green">FP32</span> vs <span class="text-wb-accent">BF16</span>
                    <span class="text-wb-muted text-xs ml-2">(per step, ms)</span>
                </div>
                <div class="h-80">
                    <canvas x-ref="precisionChart"></canvas>
                </div>
            </div>

            <!-- Charts Row -->
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 mb-4">
                <div class="bg-wb-card border border-wb-border rounded-lg p-4">
                    <div class="text-sm font-medium text-white mb-3">Operation Breakdown (Forward)</div>
                    <div class="h-64 flex items-center justify-center">
                        <canvas x-ref="opChart"></canvas>
                    </div>
                </div>
                <div class="bg-wb-card border border-wb-border rounded-lg p-4">
                    <div class="text-sm font-medium text-white mb-3">Forward vs Fwd+Bwd</div>
                    <div class="h-64">
                        <canvas x-ref="compareChart"></canvas>
                    </div>
                </div>
            </div>

            <!-- Top Kernels Comparison -->
            <div class="bg-wb-card border border-wb-border rounded-lg p-4 mb-4">
                <div class="text-sm font-medium text-white mb-3">Top Kernels: <span class="text-wb-green">Forward</span> vs <span class="text-wb-accent">Fwd+Bwd</span> vs <span class="text-wb-blue">Train</span></div>
                <div style="height: 900px;">
                    <canvas x-ref="kernelsCompareChart"></canvas>
                </div>
            </div>

            <!-- Attention Comparison -->
            <div class="bg-wb-card border border-wb-border rounded-lg p-4 mb-4">
                <div class="text-sm font-medium text-white mb-3">Attention Operations: <span class="text-wb-green">Forward</span> vs <span class="text-wb-accent">Fwd+Bwd</span> vs <span class="text-wb-blue">Train</span></div>
                <div class="h-64">
                    <canvas x-ref="attnCompareChart"></canvas>
                </div>
            </div>

            <!-- Table -->
            <div class="bg-wb-card border border-wb-border rounded-lg overflow-hidden">
                <div class="flex items-center justify-between p-3 border-b border-wb-border">
                    <div class="text-sm font-medium text-white">Kernel Events</div>
                    <div class="flex items-center gap-2">
                        <select x-model="tablePass" @change="updateTable()" class="bg-wb-bg border border-wb-border rounded px-2 py-1 text-xs text-wb-text">
                            <option value="forward">Forward Only</option>
                            <option value="backward">Fwd + Bwd</option>
                            <option value="train">Train Step</option>
                        </select>
                        <input type="text" x-model="searchQuery" @input="updateTable()" placeholder="Search..." 
                               class="bg-wb-bg border border-wb-border rounded px-2 py-1 text-xs text-wb-text w-40 focus:border-wb-accent focus:outline-none">
                    </div>
                </div>
                <div class="table-scroll overflow-auto max-h-96">
                    <table class="w-full text-xs">
                        <thead class="sticky top-0 bg-wb-card border-b border-wb-border">
                            <tr class="text-left text-wb-muted">
                                <th class="px-3 py-2 font-medium cursor-pointer hover:text-wb-text" @click="sortBy('name')">
                                    Name <span x-show="sortCol === 'name'" x-text="sortDir === 'asc' ? '↑' : '↓'"></span>
                                </th>
                                <th class="px-3 py-2 font-medium text-right cursor-pointer hover:text-wb-text" @click="sortBy('cuda_time_ms')">
                                    CUDA <span x-show="sortCol === 'cuda_time_ms'" x-text="sortDir === 'asc' ? '↑' : '↓'"></span>
                                </th>
                                <th class="px-3 py-2 font-medium text-right cursor-pointer hover:text-wb-text" @click="sortBy('cuda_time_pct')">
                                    % <span x-show="sortCol === 'cuda_time_pct'" x-text="sortDir === 'asc' ? '↑' : '↓'"></span>
                                </th>
                                <th class="px-3 py-2 font-medium text-right cursor-pointer hover:text-wb-text" @click="sortBy('count')">
                                    Count <span x-show="sortCol === 'count'" x-text="sortDir === 'asc' ? '↑' : '↓'"></span>
                                </th>
                                <th class="px-3 py-2 font-medium text-right">Avg (μs)</th>
                                <th class="px-3 py-2 font-medium text-right">CPU</th>
                            </tr>
                        </thead>
                        <tbody>
                            <template x-for="(e, idx) in filteredEvents" :key="e.name + e.cuda_time_ms">
                                <tr class="border-b border-wb-border/50 hover:bg-wb-hover" :class="getRowClass(e.name)">
                                    <td class="px-3 py-1.5 mono cursor-pointer select-none" 
                                        :class="expandedRow === idx ? 'whitespace-normal break-all' : 'truncate max-w-md'"
                                        :title="expandedRow === idx ? '' : 'Click to expand'"
                                        @click="expandedRow = expandedRow === idx ? null : idx"
                                        x-text="e.name"></td>
                                    <td class="px-3 py-1.5 text-right stat-value" x-text="e.cuda_time_ms.toFixed(2) + ' ms'"></td>
                                    <td class="px-3 py-1.5 text-right stat-value" x-text="e.cuda_time_pct.toFixed(1) + '%'"></td>
                                    <td class="px-3 py-1.5 text-right stat-value" x-text="e.count.toLocaleString()"></td>
                                    <td class="px-3 py-1.5 text-right stat-value text-wb-muted" x-text="e.cuda_time_avg_us.toFixed(1)"></td>
                                    <td class="px-3 py-1.5 text-right stat-value text-wb-muted" x-text="e.cpu_time_ms.toFixed(2) + ' ms'"></td>
                                </tr>
                            </template>
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Export -->
            <div class="mt-4 flex items-center gap-2">
                <button @click="copyExport()" class="bg-wb-card border border-wb-border hover:border-wb-accent text-wb-text text-xs px-3 py-1.5 rounded transition">
                    <span x-text="copied ? '✓ Copied' : 'Copy Summary'"></span>
                </button>
                <button @click="showExport = !showExport" class="text-wb-muted hover:text-wb-text text-xs">
                    <span x-text="showExport ? 'Hide' : 'Show'"></span> export
                </button>
            </div>
            <pre x-show="showExport" x-text="exportText" class="mt-2 bg-wb-card border border-wb-border rounded p-3 text-xs mono text-wb-muted overflow-x-auto"></pre>
        </div>
    </div>

    <script>
        function profileViewer() {
            return {
                data: null,
                selectedIndex: 0,
                model: null,
                isDragging: false,
                tablePass: 'forward',
                searchQuery: '',
                sortCol: 'cuda_time_ms',
                sortDir: 'desc',
                filteredEvents: [],
                copied: false,
                showExport: false,
                expandedRow: null,
                charts: {},

                categoryPatterns: {
                    'MatMul': [/cutlass/i, /gemm/i, /bmm/i, /einsum/i, /matmul/i],
                    'Attention': [/sdpa\//i, /attn\//i, /attention/i],
                    'Norm': [/rmsnorm/i, /layernorm/i, /norm/i],
                    'FFN': [/ffn\//i, /block\/ffn/i],
                    'Linear': [/linear/i, /proj/i],
                    'Softmax': [/softmax/i],
                    'Optimizer': [/adam/i, /sgd/i, /optimizer/i, /step/i, /param.*update/i],
                    'Memory': [/copy/i, /memcpy/i, /clone/i],
                    'Elem': [/elementwise/i, /add/i, /mul/i, /div/i, /sub/i],
                    'RoPE': [/rope/i],
                },

                categoryColors: {
                    'MatMul': '#f59e0b', 'Attention': '#a371f7', 'Norm': '#f85149', 'FFN': '#3fb950',
                    'Linear': '#58a6ff', 'Softmax': '#79c0ff', 'Optimizer': '#ff7b72', 'Memory': '#8b949e', 
                    'Elem': '#d2a8ff', 'RoPE': '#ffa657', 'Other': '#484f58',
                },

                init() {
                    Chart.defaults.color = '#8b949e';
                    Chart.defaults.borderColor = '#30363d';
                },

                get modelMeta() {
                    if (!this.model) return [];
                    return [
                        { label: 'Precision', value: this.model.precision || (this.model.use_amp ? 'BF16' : 'FP32') },
                        { label: 'Layers', value: this.model.num_layers },
                        { label: 'Heads', value: this.model.num_heads },
                        { label: 'd_model', value: this.model.d_model },
                        { label: 'd_ff', value: this.model.d_ff },
                        { label: 'Batch', value: this.model.batch_size },
                        { label: 'Steps', value: this.model.num_steps },
                    ].filter(x => x.value != null);
                },

                get numSteps() {
                    return this.model?.num_steps || 1;
                },

                get fwdPerStep() {
                    const total = this.model?.forward?.total_cuda_time_ms;
                    return total ? total / this.numSteps : null;
                },

                get fwdBwdPerStep() {
                    const total = this.model?.backward?.total_cuda_time_ms;
                    return total ? total / this.numSteps : null;
                },

                get bwdOnlyPerStep() {
                    const fwd = this.fwdPerStep;
                    const fwdBwd = this.fwdBwdPerStep;
                    return (fwd && fwdBwd) ? fwdBwd - fwd : null;
                },

                get trainPerStep() {
                    const total = this.model?.train?.total_cuda_time_ms;
                    return total ? total / this.numSteps : null;
                },

                get optimOnlyPerStep() {
                    const train = this.trainPerStep;
                    const fwdBwd = this.fwdBwdPerStep;
                    return (train && fwdBwd) ? train - fwdBwd : null;
                },

                get bwdFwdRatio() {
                    const fwd = this.fwdPerStep;
                    const bwdOnly = this.bwdOnlyPerStep;
                    return (fwd && bwdOnly) ? (bwdOnly / fwd).toFixed(2) + 'x' : '--';
                },

                get hasPrecisionComparison() {
                    if (!this.data || this.data.length < 2) return false;
                    // Check if we have both FP32 and BF16 data for any model size
                    const sizes = new Set(this.data.map(d => d.size));
                    for (const size of sizes) {
                        const models = this.data.filter(d => d.size === size);
                        const hasFP32 = models.some(d => !d.use_amp && d.precision !== 'BF16');
                        const hasBF16 = models.some(d => d.use_amp || d.precision === 'BF16');
                        if (hasFP32 && hasBF16) return true;
                    }
                    return false;
                },

                get precisionComparisonData() {
                    if (!this.data) return null;
                    // Group by model size
                    const sizeOrder = ['small', 'medium', 'large', 'xl', '2.7B'];
                    const sizes = [...new Set(this.data.map(d => d.size))].sort(
                        (a, b) => (sizeOrder.indexOf(a) ?? 999) - (sizeOrder.indexOf(b) ?? 999)
                    );
                    
                    const result = { sizes: [], fp32: { fwd: [], bwd: [], train: [] }, bf16: { fwd: [], bwd: [], train: [] } };
                    
                    for (const size of sizes) {
                        const models = this.data.filter(d => d.size === size);
                        const fp32 = models.find(d => !d.use_amp && d.precision !== 'BF16');
                        const bf16 = models.find(d => d.use_amp || d.precision === 'BF16');
                        
                        if (fp32 || bf16) {
                            result.sizes.push(size);
                            const fp32Steps = fp32?.num_steps || 1;
                            const bf16Steps = bf16?.num_steps || 1;
                            
                            result.fp32.fwd.push(fp32 ? (fp32.forward?.total_cuda_time_ms || 0) / fp32Steps : 0);
                            result.fp32.bwd.push(fp32 ? (fp32.backward?.total_cuda_time_ms || 0) / fp32Steps : 0);
                            result.fp32.train.push(fp32 ? (fp32.train?.total_cuda_time_ms || 0) / fp32Steps : 0);
                            
                            result.bf16.fwd.push(bf16 ? (bf16.forward?.total_cuda_time_ms || 0) / bf16Steps : 0);
                            result.bf16.bwd.push(bf16 ? (bf16.backward?.total_cuda_time_ms || 0) / bf16Steps : 0);
                            result.bf16.train.push(bf16 ? (bf16.train?.total_cuda_time_ms || 0) / bf16Steps : 0);
                        }
                    }
                    return result;
                },

                get exportText() {
                    if (!this.model) return '';
                    const m = this.model, fwd = m.forward, fwdBwd = m.backward;
                    const cats = this.categorize(fwd?.top_events || []);
                    let t = `Profile Summary (per step)\n${'='.repeat(50)}\n`;
                    t += `Model: ${m.size || 'unknown'} | Params: ${this.formatParams(m.num_params)} | Context: ${m.context_length}\n`;
                    t += `Layers: ${m.num_layers} | Heads: ${m.num_heads} | Batch: ${m.batch_size} | Steps: ${m.num_steps}\n\n`;
                    t += `Forward Only CUDA: ${this.formatTime(this.fwdPerStep)}\n`;
                    t += `Fwd+Bwd CUDA: ${this.formatTime(this.fwdBwdPerStep)}\n`;
                    t += `Train Step CUDA: ${this.formatTime(this.trainPerStep)}\n`;
                    t += `Bwd Only CUDA: ${this.formatTime(this.bwdOnlyPerStep)}\n`;
                    t += `Optim Only CUDA: ${this.formatTime(this.optimOnlyPerStep)}\n`;
                    t += `Bwd/Fwd Ratio: ${this.bwdFwdRatio}\n\n`;
                    t += `Forward Breakdown (per step):\n`;
                    const perStepDivisor = this.numSteps;
                    Object.entries(cats).sort((a,b) => b[1]-a[1]).forEach(([k,v]) => {
                        const perStep = v / perStepDivisor;
                        t += `  ${k}: ${perStep.toFixed(2)}ms (${(v/fwd.total_cuda_time_ms*100).toFixed(1)}%)\n`;
                    });
                    return t;
                },

                handleFile(e) {
                    const file = e.target.files[0];
                    if (file) this.loadFile(file);
                },

                handleDrop(e) {
                    const file = e.dataTransfer.files[0];
                    if (file) this.loadFile(file);
                },

                loadFile(file) {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            let d = JSON.parse(e.target.result);
                            this.data = Array.isArray(d) ? d : [d];
                            this.selectedIndex = 0;
                            this.onModelChange();
                        } catch (err) { alert('Error: ' + err.message); }
                    };
                    reader.readAsText(file);
                },

                loadDemo() {
                    this.data = DEMO_DATA;  // Already an array with FP32/BF16 comparison
                    this.selectedIndex = 0;
                    this.onModelChange();
                },

                onModelChange() {
                    this.model = this.data[this.selectedIndex];
                    this.$nextTick(() => {
                        this.updateTable();
                        this.renderCharts();
                    });
                },

                updateTable() {
                    const events = this.model?.[this.tablePass]?.top_events || [];
                    // Aggregate events with the same name
                    const aggregated = new Map();
                    events.forEach(e => {
                        if (aggregated.has(e.name)) {
                            const existing = aggregated.get(e.name);
                            existing.cuda_time_ms += e.cuda_time_ms;
                            existing.cuda_time_pct += e.cuda_time_pct;
                            existing.cpu_time_ms += e.cpu_time_ms;
                            existing.count += e.count;
                            existing.cuda_time_avg_us = (existing.cuda_time_ms * 1000) / existing.count;
                        } else {
                            aggregated.set(e.name, { ...e });
                        }
                    });
                    let filtered = [...aggregated.values()].filter(e => e.name.toLowerCase().includes(this.searchQuery.toLowerCase()));
                    filtered.sort((a, b) => {
                        let av = a[this.sortCol], bv = b[this.sortCol];
                        if (typeof av === 'string') { av = av.toLowerCase(); bv = bv.toLowerCase(); }
                        return this.sortDir === 'asc' ? (av < bv ? -1 : 1) : (av > bv ? -1 : 1);
                    });
                    this.filteredEvents = filtered;
                    this.expandedRow = null; // Reset expanded row when table changes
                },

                sortBy(col) {
                    if (this.sortCol === col) {
                        this.sortDir = this.sortDir === 'asc' ? 'desc' : 'asc';
                    } else {
                        this.sortCol = col;
                        this.sortDir = 'desc';
                    }
                    this.updateTable();
                },

                categorize(events) {
                    const cats = {};
                    Object.keys(this.categoryPatterns).forEach(k => cats[k] = 0);
                    cats['Other'] = 0;
                    events.forEach(e => {
                        let found = false;
                        for (const [cat, pats] of Object.entries(this.categoryPatterns)) {
                            if (pats.some(p => p.test(e.name))) { cats[cat] += e.cuda_time_ms; found = true; break; }
                        }
                        if (!found) cats['Other'] += e.cuda_time_ms;
                    });
                    return Object.fromEntries(Object.entries(cats).filter(([,v]) => v > 0));
                },

                categorizeAttention(events) {
                    const ops = { 'Attn Scores': 0, 'Softmax': 0, 'Output MatMul': 0, 'Mask': 0, 'RoPE': 0, 'Other': 0 };
                    events.forEach(e => {
                        const n = e.name.toLowerCase();
                        if (n.includes('attention_scores')) ops['Attn Scores'] += e.cuda_time_ms;
                        else if (n.includes('softmax')) ops['Softmax'] += e.cuda_time_ms;
                        else if (n.includes('output_matmul')) ops['Output MatMul'] += e.cuda_time_ms;
                        else if (n.includes('mask')) ops['Mask'] += e.cuda_time_ms;
                        else if (n.includes('rope')) ops['RoPE'] += e.cuda_time_ms;
                        else if (n.includes('sdpa') || n.includes('attn')) ops['Other'] += e.cuda_time_ms;
                    });
                    return Object.fromEntries(Object.entries(ops).filter(([,v]) => v > 0));
                },

                renderCharts() {
                    this.renderPrecisionChart();
                    this.renderOpChart();
                    this.renderCompareChart();
                    this.renderKernelsCompareChart();
                    this.renderAttnCompareChart();
                },

                renderPrecisionChart() {
                    const ctx = this.$refs.precisionChart?.getContext('2d');
                    if (!ctx || !this.hasPrecisionComparison) return;
                    
                    const data = this.precisionComparisonData;
                    if (!data) return;
                    
                    if (this.charts.precision) this.charts.precision.destroy();
                    
                    this.charts.precision = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: data.sizes,
                            datasets: [
                                { label: 'FP32 Forward', data: data.fp32.fwd, backgroundColor: '#3fb950', stack: 'fp32' },
                                { label: 'FP32 Bwd Only', data: data.fp32.bwd.map((v, i) => v - data.fp32.fwd[i]), backgroundColor: '#22863a', stack: 'fp32' },
                                { label: 'FP32 Optim', data: data.fp32.train.map((v, i) => v - data.fp32.bwd[i]), backgroundColor: '#144620', stack: 'fp32' },
                                { label: 'BF16 Forward', data: data.bf16.fwd, backgroundColor: '#f59e0b', stack: 'bf16' },
                                { label: 'BF16 Bwd Only', data: data.bf16.bwd.map((v, i) => v - data.bf16.fwd[i]), backgroundColor: '#b45309', stack: 'bf16' },
                                { label: 'BF16 Optim', data: data.bf16.train.map((v, i) => v - data.bf16.bwd[i]), backgroundColor: '#78350f', stack: 'bf16' },
                            ]
                        },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: {
                                legend: { labels: { boxWidth: 12, font: { size: 11 } } },
                                tooltip: {
                                    callbacks: {
                                        label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(2)} ms`,
                                        afterBody: (items) => {
                                            const idx = items[0].dataIndex;
                                            const fp32Total = data.fp32.train[idx];
                                            const bf16Total = data.bf16.train[idx];
                                            if (fp32Total && bf16Total) {
                                                const speedup = (fp32Total / bf16Total).toFixed(2);
                                                return `\nSpeedup: ${speedup}x`;
                                            }
                                            return '';
                                        }
                                    }
                                }
                            },
                            scales: {
                                x: { grid: { display: false }, ticks: { font: { size: 11 } } },
                                y: { 
                                    grid: { color: '#21262d' }, 
                                    ticks: { font: { size: 10 } },
                                    title: { display: true, text: 'Time (ms)', font: { size: 10 } },
                                    stacked: true
                                }
                            }
                        }
                    });
                },

                renderOpChart() {
                    const ctx = this.$refs.opChart?.getContext('2d');
                    if (!ctx) return;
                    const cats = this.categorize(this.model?.forward?.top_events || []);
                    if (this.charts.op) this.charts.op.destroy();
                    this.charts.op = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(cats),
                            datasets: [{ data: Object.values(cats), backgroundColor: Object.keys(cats).map(k => this.categoryColors[k] || this.categoryColors.Other), borderWidth: 0 }]
                        },
                        options: {
                            responsive: true, maintainAspectRatio: false,
                            plugins: {
                                legend: { position: 'right', labels: { boxWidth: 12, padding: 8, font: { size: 11 } } },
                                tooltip: { callbacks: { label: ctx => `${ctx.label}: ${ctx.raw.toFixed(1)}ms` } }
                            }
                        }
                    });
                },

                renderCompareChart() {
                    const ctx = this.$refs.compareChart?.getContext('2d');
                    if (!ctx) return;
                    const fwdCats = this.categorize(this.model?.forward?.top_events || []);
                    const bwdCats = this.categorize(this.model?.backward?.top_events || []);
                    const trainCats = this.categorize(this.model?.train?.top_events || []);
                    const labels = [...new Set([...Object.keys(fwdCats), ...Object.keys(bwdCats), ...Object.keys(trainCats)])];
                    if (this.charts.compare) this.charts.compare.destroy();
                    this.charts.compare = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels,
                            datasets: [
                                { label: 'Forward', data: labels.map(l => fwdCats[l] || 0), backgroundColor: '#3fb950' },
                                { label: 'Fwd+Bwd', data: labels.map(l => bwdCats[l] || 0), backgroundColor: '#f59e0b' },
                                { label: 'Train', data: labels.map(l => trainCats[l] || 0), backgroundColor: '#58a6ff' },
                            ]
                        },
                        options: {
                            responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                            plugins: { legend: { labels: { boxWidth: 12, font: { size: 11 } } } },
                            scales: {
                                x: { grid: { color: '#21262d' }, ticks: { font: { size: 10 } }, title: { display: true, text: 'ms', font: { size: 10 } } },
                                y: { grid: { display: false }, ticks: { font: { size: 10 } } }
                            }
                        }
                    });
                },

                renderKernelsCompareChart() {
                    const ctx = this.$refs.kernelsCompareChart?.getContext('2d');
                    if (!ctx) return;
                    
                    // Get top kernels from all passes and merge by name
                    const fwdEvents = this.model?.forward?.top_events || [];
                    const bwdEvents = this.model?.backward?.top_events || [];
                    const trainEvents = this.model?.train?.top_events || [];
                    
                    // Create a map of all kernel names with their times
                    const kernelMap = new Map();
                    fwdEvents.forEach(e => kernelMap.set(e.name, { fwd: e.cuda_time_ms, bwd: 0, train: 0 }));
                    bwdEvents.forEach(e => {
                        if (kernelMap.has(e.name)) {
                            kernelMap.get(e.name).bwd = e.cuda_time_ms;
                        } else {
                            kernelMap.set(e.name, { fwd: 0, bwd: e.cuda_time_ms, train: 0 });
                        }
                    });
                    trainEvents.forEach(e => {
                        if (kernelMap.has(e.name)) {
                            kernelMap.get(e.name).train = e.cuda_time_ms;
                        } else {
                            kernelMap.set(e.name, { fwd: 0, bwd: 0, train: e.cuda_time_ms });
                        }
                    });
                    
                    // Sort by max time across all passes and take top 30
                    const sorted = [...kernelMap.entries()]
                        .sort((a, b) => Math.max(b[1].fwd, b[1].bwd, b[1].train) - Math.max(a[1].fwd, a[1].bwd, a[1].train))
                        .slice(0, 30);
                    
                    const labels = sorted.map(([name]) => this.truncate(name, 28));
                    const fullNames = sorted.map(([name]) => name);
                    const fwdData = sorted.map(([, v]) => v.fwd);
                    const bwdData = sorted.map(([, v]) => v.bwd);
                    const trainData = sorted.map(([, v]) => v.train);
                    
                    if (this.charts.kernelsCompare) this.charts.kernelsCompare.destroy();
                    this.charts.kernelsCompare = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels,
                            datasets: [
                                { label: 'Forward', data: fwdData, backgroundColor: '#3fb950' },
                                { label: 'Fwd+Bwd', data: bwdData, backgroundColor: '#f59e0b' },
                                { label: 'Train', data: trainData, backgroundColor: '#58a6ff' },
                            ]
                        },
                        options: {
                            responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                            plugins: {
                                legend: { labels: { boxWidth: 12, font: { size: 11 } } },
                                tooltip: { 
                                    callbacks: { 
                                        title: ctx => fullNames[ctx[0].dataIndex],
                                        label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(2)}ms`
                                    } 
                                }
                            },
                            scales: {
                                x: { grid: { color: '#21262d' }, ticks: { font: { size: 10 } }, title: { display: true, text: 'ms', font: { size: 10 } } },
                                y: { grid: { display: false }, ticks: { font: { size: 9 } } }
                            }
                        }
                    });
                },

                renderAttnCompareChart() {
                    const ctx = this.$refs.attnCompareChart?.getContext('2d');
                    if (!ctx) return;
                    
                    const fwdOps = this.categorizeAttention(this.model?.forward?.top_events || []);
                    const bwdOps = this.categorizeAttention(this.model?.backward?.top_events || []);
                    const trainOps = this.categorizeAttention(this.model?.train?.top_events || []);
                    const labels = [...new Set([...Object.keys(fwdOps), ...Object.keys(bwdOps), ...Object.keys(trainOps)])];
                    
                    if (this.charts.attnCompare) this.charts.attnCompare.destroy();
                    this.charts.attnCompare = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels,
                            datasets: [
                                { label: 'Forward', data: labels.map(l => fwdOps[l] || 0), backgroundColor: '#3fb950' },
                                { label: 'Fwd+Bwd', data: labels.map(l => bwdOps[l] || 0), backgroundColor: '#f59e0b' },
                                { label: 'Train', data: labels.map(l => trainOps[l] || 0), backgroundColor: '#58a6ff' },
                            ]
                        },
                        options: {
                            responsive: true, maintainAspectRatio: false, indexAxis: 'y',
                            plugins: {
                                legend: { labels: { boxWidth: 12, font: { size: 11 } } },
                                tooltip: { callbacks: { label: ctx => `${ctx.dataset.label}: ${ctx.raw.toFixed(2)}ms` } }
                            },
                            scales: {
                                x: { grid: { color: '#21262d' }, ticks: { font: { size: 10 } }, title: { display: true, text: 'ms', font: { size: 10 } } },
                                y: { grid: { display: false }, ticks: { font: { size: 10 } } }
                            }
                        }
                    });
                },

                getKernelColor(name) {
                    for (const [cat, pats] of Object.entries(this.categoryPatterns)) {
                        if (pats.some(p => p.test(name))) return this.categoryColors[cat];
                    }
                    return this.categoryColors.Other;
                },

                getRowClass(name) {
                    if (/cutlass|gemm|bmm|einsum|matmul/i.test(name)) return 'bg-amber-500/5';
                    if (/sdpa|attn|attention/i.test(name)) return 'bg-purple-500/5';
                    return '';
                },

                copyExport() {
                    navigator.clipboard.writeText(this.exportText);
                    this.copied = true;
                    setTimeout(() => this.copied = false, 2000);
                },

                formatTime(ms) {
                    if (ms == null) return '--';
                    return ms >= 1000 ? (ms / 1000).toFixed(2) + ' s' : ms.toFixed(2) + ' ms';
                },

                formatParams(n) {
                    if (n == null) return '--';
                    if (n >= 1e9) return (n / 1e9).toFixed(1) + 'B';
                    if (n >= 1e6) return (n / 1e6).toFixed(1) + 'M';
                    return n.toLocaleString();
                },

                truncate(s, len) { return s.length > len ? s.slice(0, len - 2) + '…' : s; }
            };
        }

        // Demo data with FP32 vs BF16 comparison for multiple model sizes
        const DEMO_DATA = [
            // Small FP32
            {
                size: "small", num_params: 128625408, batch_size: 4, context_length: 128,
                d_model: 768, d_ff: 3072, num_layers: 12, num_heads: 12, num_steps: 10,
                use_amp: false, precision: "FP32",
                forward: { total_cuda_time_us: 230000, total_cuda_time_ms: 230, num_events: 108, top_events: [
                    {name: "aten::mm", cuda_time_us: 45000, cuda_time_ms: 45, cuda_time_pct: 19.6, cpu_time_us: 0, cpu_time_ms: 0, count: 610, cuda_time_avg_us: 73.8},
                    {name: "aten::bmm", cuda_time_us: 38000, cuda_time_ms: 38, cuda_time_pct: 16.5, cpu_time_us: 0, cpu_time_ms: 0, count: 240, cuda_time_avg_us: 158.3},
                    {name: "rmsnorm", cuda_time_us: 28000, cuda_time_ms: 28, cuda_time_pct: 12.2, cpu_time_us: 0, cpu_time_ms: 0, count: 250, cuda_time_avg_us: 112},
                    {name: "attn/softmax", cuda_time_us: 18000, cuda_time_ms: 18, cuda_time_pct: 7.8, cpu_time_us: 0, cpu_time_ms: 0, count: 120, cuda_time_avg_us: 150},
                    {name: "aten::mul", cuda_time_us: 12000, cuda_time_ms: 12, cuda_time_pct: 5.2, cpu_time_us: 0, cpu_time_ms: 0, count: 1450, cuda_time_avg_us: 8.3}
                ]},
                backward: { total_cuda_time_us: 720000, total_cuda_time_ms: 720, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 780000, total_cuda_time_ms: 780, num_events: 250, top_events: [] }
            },
            // Small BF16
            {
                size: "small", num_params: 128625408, batch_size: 4, context_length: 128,
                d_model: 768, d_ff: 3072, num_layers: 12, num_heads: 12, num_steps: 10,
                use_amp: true, precision: "BF16",
                forward: { total_cuda_time_us: 150000, total_cuda_time_ms: 150, num_events: 108, top_events: [
                    {name: "aten::mm", cuda_time_us: 28000, cuda_time_ms: 28, cuda_time_pct: 18.7, cpu_time_us: 0, cpu_time_ms: 0, count: 610, cuda_time_avg_us: 45.9},
                    {name: "aten::bmm", cuda_time_us: 24000, cuda_time_ms: 24, cuda_time_pct: 16.0, cpu_time_us: 0, cpu_time_ms: 0, count: 240, cuda_time_avg_us: 100},
                    {name: "rmsnorm", cuda_time_us: 22000, cuda_time_ms: 22, cuda_time_pct: 14.7, cpu_time_us: 0, cpu_time_ms: 0, count: 250, cuda_time_avg_us: 88},
                    {name: "attn/softmax", cuda_time_us: 11000, cuda_time_ms: 11, cuda_time_pct: 7.3, cpu_time_us: 0, cpu_time_ms: 0, count: 120, cuda_time_avg_us: 91.7},
                    {name: "aten::mul", cuda_time_us: 8000, cuda_time_ms: 8, cuda_time_pct: 5.3, cpu_time_us: 0, cpu_time_ms: 0, count: 1450, cuda_time_avg_us: 5.5}
                ]},
                backward: { total_cuda_time_us: 480000, total_cuda_time_ms: 480, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 520000, total_cuda_time_ms: 520, num_events: 250, top_events: [] }
            },
            // Medium FP32
            {
                size: "medium", num_params: 424673280, batch_size: 4, context_length: 128,
                d_model: 1024, d_ff: 4096, num_layers: 24, num_heads: 16, num_steps: 10,
                use_amp: false, precision: "FP32",
                forward: { total_cuda_time_us: 680000, total_cuda_time_ms: 680, num_events: 108, top_events: [] },
                backward: { total_cuda_time_us: 1950000, total_cuda_time_ms: 1950, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 2100000, total_cuda_time_ms: 2100, num_events: 250, top_events: [] }
            },
            // Medium BF16
            {
                size: "medium", num_params: 424673280, batch_size: 4, context_length: 128,
                d_model: 1024, d_ff: 4096, num_layers: 24, num_heads: 16, num_steps: 10,
                use_amp: true, precision: "BF16",
                forward: { total_cuda_time_us: 420000, total_cuda_time_ms: 420, num_events: 108, top_events: [] },
                backward: { total_cuda_time_us: 1200000, total_cuda_time_ms: 1200, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 1300000, total_cuda_time_ms: 1300, num_events: 250, top_events: [] }
            },
            // Large FP32
            {
                size: "large", num_params: 973078528, batch_size: 4, context_length: 128,
                d_model: 1280, d_ff: 5120, num_layers: 36, num_heads: 20, num_steps: 10,
                use_amp: false, precision: "FP32",
                forward: { total_cuda_time_us: 1450000, total_cuda_time_ms: 1450, num_events: 108, top_events: [] },
                backward: { total_cuda_time_us: 4200000, total_cuda_time_ms: 4200, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 4500000, total_cuda_time_ms: 4500, num_events: 250, top_events: [] }
            },
            // Large BF16
            {
                size: "large", num_params: 973078528, batch_size: 4, context_length: 128,
                d_model: 1280, d_ff: 5120, num_layers: 36, num_heads: 20, num_steps: 10,
                use_amp: true, precision: "BF16",
                forward: { total_cuda_time_us: 850000, total_cuda_time_ms: 850, num_events: 108, top_events: [] },
                backward: { total_cuda_time_us: 2500000, total_cuda_time_ms: 2500, num_events: 211, top_events: [] },
                train: { total_cuda_time_us: 2700000, total_cuda_time_ms: 2700, num_events: 250, top_events: [] }
            }
        ];
    </script>
</body>
</html>
